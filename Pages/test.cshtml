@page "/test"

@using System.Net

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimal htmx Example</title>
</head>
<body>

	<div jx-get="test2.html" jx-target="#result2" jx-vals="a:1;b:2;c:3" jx-headers="Authorization: Bearer Token123; Custom-Header: Value123">
    <button>Load Data</button>
</div>

<div id="result2">
</div>

@{
    // Retrieve values from the query string or use default values
    string firstName = "Joe";
    string lastName = "Blow";
    string email = "joe@blow.com";
	if(HttpContext.Request.HasFormContentType){
		firstName = Request.Form["firstName"].FirstOrDefault() ?? "";
		lastName = Request.Form["lastName"].FirstOrDefault() ?? "";
		email = Request.Form["email"].FirstOrDefault() ?? "";
	}
	string queryString = $"firstName={WebUtility.UrlEncode(firstName)}&lastName={WebUtility.UrlEncode(lastName)}&email={WebUtility.UrlEncode(email)}";
}

<div id='container'>
    <div><label>First Name</label>: @firstName</div>
    <div><label>Last Name</label>: @lastName</div>
    <div><label>Email</label>: @email</div>
		<button jx-get="/test2?@queryString" jx-target='#container' jx-after="alert('interesting')">
        Click To Edit
    </button>
</div>

<script>
	(function () {
		HTMLElement.prototype.on = function (e, fn) { this.addEventListener(e, fn) }
		HTMLElement.prototype.attr = function (attribute, value) { return value === undefined ? this.getAttribute(attribute) : (this.setAttribute(attribute, value), this) }
		const $ = s => document.querySelector(s), $$ = s => document.querySelectorAll(s);
		const $DP = (htmlString, selector) => (new DOMParser().parseFromString(htmlString, 'text/html').querySelector(selector)?.innerHTML || '');
		const httpVerbs = ['get', 'post', 'put', 'delete', 'patch'];

		document.addEventListener('DOMContentLoaded', () => run());

		const run = () => {
			httpVerbs.forEach(verb => {
				const els = $$(`[jx-${verb}]:not([data-jx-applied])`);
				els.forEach(el => {
					applyLogic(el, verb);
					el.setAttribute('data-jx-applied', 'true');
				});
			});
		}

		const applyLogic = (el, verb) => {
			const url = el.attr(`jx-${verb}`), jxTarget = el.attr('jx-target'), jxTrigger = el.attr('jx-trigger');
			let targetEl = jxTarget ? $(jxTarget) : el;

			if (el instanceof HTMLFormElement) {
				el.on('submit', async (e) => {
					e.preventDefault();
					await fetchData(url, targetEl, el, { method: verb, body: new URLSearchParams(new FormData(el)) });
				});
			} else el.on(jxTrigger || 'click', async () => await fetchData(url, targetEl, el, { method: verb }));
		};

		const fetchData = async (url, targetEl, el, options = {}) => {
			const jxBefore = el.attr('jx-before'), jxAfter = el.attr('jx-after'), jxHeaders = el.attr('jx-headers'),
				jxVals = el.attr('jx-vals'), jxSwap = el.attr('jx-swap');
			if (jxBefore) eval(jxBefore);
			const method = options.method || 'get';
			if (jxVals) (method === 'get') ?
					url += '?' + (new URLSearchParams(parseAttributes(jxVals))).toString() :
					options.body = parseAttributes(jxVals);
			const response = await fetch(url, {
				...options,
				method,
				headers: {
					...options.headers,
					...parseAttributes(jxHeaders),
				},
			});
			if (!response.ok) throw new Error('Network response was not ok');
			const data = await response.text();
			const jxSelectAttribute = el.getAttribute('jx-select');
			//targetEl.innerHTML = (jxSelectAttribute) ? $DP(data, jxSelectAttribute) : data;
			applySwap(targetEl, data, jxSwap, jxSelectAttribute);
			if (jxAfter) eval(jxAfter);
			run();
		};

		const parseAttributes = (attributeValue) => {
			const attributes = {};
			if (attributeValue) {
				attributeValue.split(';').forEach(attribute => {
					const [name, value] = attribute.split(':');
					if (name && value) attributes[name.trim()] = value.trim();
				});
			}
			return attributes;
		};

		const applySwap = (targetEl, data, jxSwap, jxSelectAttribute) => {
			const contentToInsert = (jxSelectAttribute) ? $DP(data, jxSelectAttribute) : data;
			const swapActions = {
				'outerHTML': () => targetEl.outerHTML = contentToInsert,
				'append': () => targetEl.innerHTML += contentToInsert,
				'prepend': () => targetEl.innerHTML = contentToInsert + targetEl.innerHTML,
				'before': () => targetEl.insertAdjacentHTML('beforebegin', contentToInsert),
				'after': () => targetEl.insertAdjacentHTML('afterend', contentToInsert),
				'default': () => targetEl.innerHTML = contentToInsert,
			};
			const selectedAction = swapActions[jxSwap] || swapActions['default'];
			selectedAction();
		};


	})();
	
</script>

</body>
</html>